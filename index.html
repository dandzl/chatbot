<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>BTC Chart</title>
  </head>
  <body>
    <!-- Market Data Section BEGIN -->
    <div class="market-data" style="padding: 10px; background: #1e222d; color: #fff; font-family: Arial, sans-serif;">
      <span style="margin-right: 20px;">24h Volume: <span id="volume">Loading...</span></span>
      <span style="margin-right: 20px;">Open Interest: <span id="openInterest">Loading...</span></span>
      <span style="margin-right: 20px;">24h Liquidation: <span id="liquidation">Loading...</span></span>
      <span>Long/Short Ratio: <span id="longShortRatio">Loading...</span></span>
    </div>

    <!-- Chart Container BEGIN -->
    <div style="display: flex; flex-direction: column; gap: 20px; padding: 20px;">
      <!-- TradingView Widget BEGIN -->
      <div style="width: 100%; height: 600px;">
        <div id="tradingview_btc" style="width: 100%; height: 100%;"></div>
      </div>
      <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
      <script type="text/javascript">
        let tvWidget;

        tvWidget = new TradingView.widget({
          autosize: true,
          symbol: "BINANCE:BTCUSDT",
          interval: "D",
          range: "12M",
          theme: "light",
          style: "1",
          timezone: "Etc/UTC",
          container_id: "tradingview_btc",
          onChartReady: function() {
            console.log("Chart is ready");
            chartReady = true;
            // Subscribe to real-time updates
            tvWidget.activeChart().onDataLoaded().subscribe(null, () => {
              const chart = tvWidget.activeChart();
              const prices = chart.getAllSeries()[0].data();
              if (prices && prices.length > 0) {
                lastPrice = prices[prices.length - 1].close;
                const visibleRange = chart.getVisibleRange();
                const priceData = prices.filter(p => 
                  p.time >= visibleRange.from && p.time <= visibleRange.to
                );
                priceRange.min = Math.min(...priceData.map(p => p.low));
                priceRange.max = Math.max(...priceData.map(p => p.high));
              }
            });
          }
        });
      </script>
      <!-- TradingView Widget END -->
      
      <!-- Coinglass Heatmap BEGIN -->
      <div style="width: 100%; height: 600px;">
        <iframe 
          src="https://www.coinglass.com/LiquidityHeatmap" 
          style="width: 100%; height: 100%; border: none;"
          title="Coinglass Liquidity Heatmap">
        </iframe>
      </div>
    </div>
    
    <script>

      // Time-based binning state
      let timeBasedBins = new Map();
      const BIN_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds
      const BINS_TO_KEEP = 12; // Keep last hour of data
      const POLL_INTERVAL = 100; // Poll every 100ms

      // Initialize order book and start polling
      async function initOrderBook() {
        try {
          console.log('Initializing order book...');
          // Get initial snapshot from Binance using CORS proxy
          const response = await fetch('https://api.codetabs.com/v1/proxy?quest=' + 
            encodeURIComponent('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=1000'));
          const snapshot = await response.json();
          
          console.log('Received order book snapshot:', {
            asks: snapshot.asks?.length || 0,
            bids: snapshot.bids?.length || 0,
            lastUpdateId: snapshot.lastUpdateId
          });
          
          // Initialize order book with snapshot
          orderBook.lastUpdateId = snapshot.lastUpdateId;
          orderBook.asks.clear();
          orderBook.bids.clear();
          
          snapshot.asks.forEach(([price, size]) => {
            orderBook.asks.set(price, parseFloat(size));
          });
          
          snapshot.bids.forEach(([price, size]) => {
            orderBook.bids.set(price, parseFloat(size));
          });

          // Initialize time bins
          initTimeBins();
          
          // Start polling for updates
          startPolling();

          // Initial draw
          drawHeatmap();
        } catch (error) {
          console.error('Error initializing order book:', error);
          setTimeout(initOrderBook, 5000); // Retry after 5 seconds
        }
      }

      // Poll for order book updates
      async function pollOrderBook() {
        try {
          const response = await fetch('https://api.codetabs.com/v1/proxy?quest=' + 
            encodeURIComponent('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=100'));
          const data = await response.json();
          
          if (data.lastUpdateId > orderBook.lastUpdateId) {
            handleOrderBookUpdate(data);
          }
        } catch (error) {
          console.error('Error polling order book:', error);
        }
      }

      // Start polling loop
      function startPolling() {
        setInterval(pollOrderBook, POLL_INTERVAL);
      }

      // Initialize time-based bins
      function initTimeBins() {
        const now = Date.now();
        const currentBin = Math.floor(now / BIN_INTERVAL) * BIN_INTERVAL;
        
        timeBasedBins.clear();
        for (let i = 0; i < BINS_TO_KEEP; i++) {
          const binTime = currentBin - (i * BIN_INTERVAL);
          timeBasedBins.set(binTime, {
            asks: new Map(),
            bids: new Map()
          });
        }
      }

      // Handle order book updates
      function handleOrderBookUpdate(update) {
        console.log('Processing order book update:', {
          asks: update.asks?.length || 0,
          bids: update.bids?.length || 0,
          lastUpdateId: update.lastUpdateId
        });
        
        // Process asks
        update.asks.forEach(([price, size]) => {
          if (parseFloat(size) === 0) {
            orderBook.asks.delete(price);
          } else {
            orderBook.asks.set(price, parseFloat(size));
          }
        });
        
        // Process bids
        update.bids.forEach(([price, size]) => {
          if (parseFloat(size) === 0) {
            orderBook.bids.delete(price);
          } else {
            orderBook.bids.set(price, parseFloat(size));
          }
        });
        
        // Update lastUpdateId
        orderBook.lastUpdateId = update.lastUpdateId;
        
        // Update time-based bins
        const now = Date.now();
        const currentBin = Math.floor(now / BIN_INTERVAL) * BIN_INTERVAL;
        
        // Create new bin if needed
        if (!timeBasedBins.has(currentBin)) {
          timeBasedBins.set(currentBin, {
            asks: new Map(),
            bids: new Map()
          });
          
          // Remove oldest bin
          const oldestBinTime = currentBin - (BINS_TO_KEEP * BIN_INTERVAL);
          timeBasedBins.delete(oldestBinTime);
        }
        
        // Aggregate current order book into current time bin
        const currentBinData = timeBasedBins.get(currentBin);
        
        orderBook.asks.forEach((size, price) => {
          const currentSize = currentBinData.asks.get(price) || 0;
          currentBinData.asks.set(price, currentSize + size);
        });
        
        orderBook.bids.forEach((size, price) => {
          const currentSize = currentBinData.bids.get(price) || 0;
          currentBinData.bids.set(price, currentSize + size);
        });
        
        // Draw updated heatmap
        drawHeatmap();
      }

      function drawHeatmap() {
        try {
          // Get canvas context
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match container
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          
          // Clear previous drawing
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Convert order book to array format
          const allOrders = [
            ...Array.from(orderBook.asks.entries()).map(([price, size]) => ({ price: parseFloat(price), size, type: 'ask' })),
            ...Array.from(orderBook.bids.entries()).map(([price, size]) => ({ price: parseFloat(price), size, type: 'bid' }))
          ];

          if (allOrders.length === 0) return;

          // Wait for TradingView chart to be ready and have price data
          if (!chartReady || !priceRange.max) {
            console.log("Waiting for chart data...");
            return;
          }

          // Use TradingView's price range for better coordination
          const xScale = d3.scaleLinear()
            .domain([priceRange.min * 0.9985, priceRange.max * 1.0015]) // Add small padding
            .range([0, canvas.width]);

          // Create color scale (purple to green/yellow)
          const maxSize = Math.max(...allOrders.map(order => order.size));
          const colorScaleLow = d3.scaleLinear()
            .domain([0, maxSize * 0.5])
            .range(["#540D6E", "#14FFEC"]);
          const colorScaleHigh = d3.scaleLinear()
            .domain([maxSize * 0.5, maxSize])
            .range(["#14FFEC", "#F6FF00"]);
          
          const getColor = (size) => {
            return size <= maxSize * 0.5 ? colorScaleLow(size) : colorScaleHigh(size);
          };
          
          const logScale = d3.scaleLog()
            .domain([1, maxSize])
            .range([0.2, 0.8]);

          // Aggregate orders into price bins
          const binSize = (priceRange.max - priceRange.min) / 100; // 100 price levels
          const priceBins = new Map();
          
          allOrders.forEach(order => {
            const binIndex = Math.floor((order.price - priceRange.min) / binSize);
            const binPrice = priceRange.min + (binIndex * binSize);
            
            if (!priceBins.has(binPrice)) {
              priceBins.set(binPrice, { bids: 0, asks: 0 });
            }
            
            const bin = priceBins.get(binPrice);
            if (order.type === 'bid') {
              bin.bids += order.size;
            } else {
              bin.asks += order.size;
            }
          });

          // Draw aggregated heatmap with gradient
          priceBins.forEach((volumes, price) => {
            const x = xScale(price);
            const rectWidth = Math.max(2, canvas.width / priceBins.size);
            
            // Draw asks (top half)
            const askGradient = ctx.createLinearGradient(0, 0, 0, canvas.height/2);
            const askAlpha = volumes.asks > 0 ? logScale(volumes.asks) : 0;
            askGradient.addColorStop(0, getColor(volumes.asks));
            askGradient.addColorStop(0.7, `rgba(84, 13, 110, ${askAlpha * 0.7})`);
            askGradient.addColorStop(1, 'rgba(84, 13, 110, 0)');
            
            ctx.globalAlpha = askAlpha;
            ctx.fillStyle = askGradient;
            ctx.fillRect(x, 0, rectWidth, canvas.height/2);
            
            // Draw bids (bottom half)
            const bidGradient = ctx.createLinearGradient(0, canvas.height/2, 0, canvas.height);
            const bidAlpha = volumes.bids > 0 ? logScale(volumes.bids) : 0;
            bidGradient.addColorStop(0, 'rgba(84, 13, 110, 0)');
            bidGradient.addColorStop(0.3, `rgba(84, 13, 110, ${bidAlpha * 0.7})`);
            bidGradient.addColorStop(1, getColor(volumes.bids));
            
            ctx.globalAlpha = bidAlpha;
            ctx.fillStyle = bidGradient;
            ctx.fillRect(x, canvas.height/2, rectWidth, canvas.height/2);
          });
        } catch (err) {
          console.error("Error rendering heatmap:", err);
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'red';
          ctx.font = '14px Arial';
          ctx.fillText('Error rendering heatmap. Please check console for details.', 10, 20);
        }
      }

      // Market Data Functions
      async function updateMarketData() {
        try {
          // Fetch data from Binance API with better CORS proxy
          const [volumeRes, oiRes] = await Promise.all([
            fetch('https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT')),
            fetch('https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent('https://fapi.binance.com/futures/data/openInterestHist?symbol=BTCUSDT&period=5m&limit=1'))
          ]);

          const volumeData = await volumeRes.json();
          const oiData = await oiRes.json();

          // Validate and format volume data
          if (!volumeData || !volumeData.volume || !volumeData.lastPrice) {
            throw new Error('Invalid volume data structure');
          }
          const volume = parseFloat(volumeData.volume * volumeData.lastPrice);
          document.getElementById('volume').textContent = '$' + (volume / 1e9).toFixed(2) + 'B';

          // Validate and format open interest data
          if (!oiData || !Array.isArray(oiData) || oiData.length === 0 || !oiData[0].sumOpenInterest) {
            throw new Error('Invalid open interest data structure');
          }
          const oi = parseFloat(oiData[0].sumOpenInterest);
          document.getElementById('openInterest').textContent = '$' + (oi / 1e9).toFixed(2) + 'B';

          // Simulate liquidation and L/S ratio (as these require paid API access)
          const mockLiq = (Math.random() * 100 + 200).toFixed(2);
          const mockLSRatio = (Math.random() * 0.2 + 0.9).toFixed(2);
          
          document.getElementById('liquidation').textContent = '$' + mockLiq + 'M';
          document.getElementById('longShortRatio').textContent = mockLSRatio;
        } catch (err) {
          console.error('Error updating market data:', err);
          ['volume', 'openInterest', 'liquidation', 'longShortRatio'].forEach(id => {
            document.getElementById(id).textContent = 'Error loading data';
          });
        }
      }

      // Initialize order book and market data with polling
      let lastUpdateId = 0;
      
      async function pollOrderBook() {
        try {
          console.log('Polling order book...');
          const response = await fetch('https://api.codetabs.com/v1/proxy?quest=' + 
            encodeURIComponent(`https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=1000`));
          const data = await response.json();
          
          if (data.lastUpdateId <= lastUpdateId) {
            console.log('Skipping older update:', { lastUpdateId, newUpdateId: data.lastUpdateId });
            return;
          }
          
          console.log('Processing order book update:', {
            asks: data.asks?.length || 0,
            bids: data.bids?.length || 0,
            lastUpdateId: data.lastUpdateId
          });
          
          // Clear existing order book
          orderBook.asks.clear();
          orderBook.bids.clear();
          
          // Process new snapshot
          data.asks.forEach(([price, size]) => {
            orderBook.asks.set(price, parseFloat(size));
          });
          
          data.bids.forEach(([price, size]) => {
            orderBook.bids.set(price, parseFloat(size));
          });
          
          lastUpdateId = data.lastUpdateId;
          
          // Update visualization
          renderHeatmap();
        } catch (err) {
          console.error('Error polling order book:', err);
        }
      }
      
      // Start polling
      pollOrderBook();
      updateMarketData();
      
      // Poll every 5 seconds for order book
      setInterval(pollOrderBook, 5000);
      // Poll every 10 seconds for market data
      setInterval(updateMarketData, 10000);
    </script>
    <script>
      // Initialize canvas for heatmap overlay
      const canvas = document.createElement('canvas');
      canvas.id = 'heatmapOverlay';
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      
      // Initialize order book state
      const orderBook = {
        asks: new Map(),
        bids: new Map(),
        timeData: new Map(),
        maxVolume: 0
      };
      
      function renderHeatmap() {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Get current price from TradingView widget
        const currentPrice = parseFloat(document.querySelector('[data-name="legend-price-value"]')?.textContent) || 0;
        const priceRange = currentPrice * 0.1; // 10% range
        
        // Calculate volume ranges for color scaling
        const volumes = Array.from(orderBook.timeData.values());
        const maxVolume = Math.max(...volumes, 1);
        orderBook.maxVolume = Math.max(orderBook.maxVolume, maxVolume);
        
        // Draw heatmap
        orderBook.timeData.forEach((volume, key) => {
          const [timestamp, price] = key.split('_').map(Number);
          const age = Date.now() - timestamp;
          const alpha = Math.max(0, 1 - age / (5 * 60 * 1000)); // Fade over 5 minutes
          
          // Calculate relative position
          const relativePrice = (price - currentPrice) / priceRange;
          const y = canvas.height * (0.5 - relativePrice * 0.5);
          
          // Calculate color intensity based on volume
          const intensity = Math.log(volume + 1) / Math.log(orderBook.maxVolume + 1);
          const color = price >= currentPrice ? 
            `rgba(255,0,0,${alpha * intensity})` : 
            `rgba(0,255,0,${alpha * intensity})`;
          
          // Draw volume bar
          ctx.fillStyle = color;
          ctx.fillRect(0, y, canvas.width, 2);
        });
      }

      // Initialize everything when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Content loaded, initializing...');
        // Start market data polling
        updateMarketData();
        // Set up polling interval for market data
        setInterval(updateMarketData, 10000);
      });
    </script>
  </body>
</html>
