<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>BTC Chart</title>
  </head>
  <body>
    <!-- Market Data Section BEGIN -->
    <div class="market-data" style="padding: 10px; background: #1e222d; color: #fff; font-family: Arial, sans-serif;">
      <span style="margin-right: 20px;">24h Volume: <span id="volVal">Loading...</span></span>
      <span style="margin-right: 20px;">Open Interest: <span id="oiVal">Loading...</span></span>
      <span style="margin-right: 20px;">24h Liquidation: <span id="liqVal">Loading...</span></span>
      <span>Long/Short Ratio: <span id="lsVal">Loading...</span></span>
    </div>

    <!-- Chart Container BEGIN -->
    <div style="position: relative; width: 800px; height: 600px;">
      <!-- TradingView Widget BEGIN -->
      <div id="tradingview_btc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
      <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
      <script type="text/javascript">
        let tvWidget;
        let chartReady = false;
        let lastPrice = 0;
        let priceRange = { min: 0, max: 0 };

        tvWidget = new TradingView.widget({
          autosize: true,
          symbol: "BINANCE:BTCUSDT",
          interval: "D",
          range: "12M",
          theme: "light",
          style: "1",
          timezone: "Etc/UTC",
          container_id: "tradingview_btc",
          onChartReady: function() {
            console.log("Chart is ready");
            chartReady = true;
            // Subscribe to real-time updates
            tvWidget.activeChart().onDataLoaded().subscribe(null, () => {
              const chart = tvWidget.activeChart();
              const prices = chart.getAllSeries()[0].data();
              if (prices && prices.length > 0) {
                lastPrice = prices[prices.length - 1].close;
                const visibleRange = chart.getVisibleRange();
                const priceData = prices.filter(p => 
                  p.time >= visibleRange.from && p.time <= visibleRange.to
                );
                priceRange.min = Math.min(...priceData.map(p => p.low));
                priceRange.max = Math.max(...priceData.map(p => p.high));
              }
            });
          }
        });
      </script>
      <!-- TradingView Widget END -->
      
      <!-- Heatmap Overlay BEGIN -->
      <canvas id="heatmapCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
    </div>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      // OrderBook state
      let orderBook = {
        asks: new Map(),
        bids: new Map(),
        lastUpdateId: 0
      };

      // Time-based binning state
      let timeBasedBins = new Map();
      const BIN_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds
      const BINS_TO_KEEP = 12; // Keep last hour of data
      const POLL_INTERVAL = 100; // Poll every 100ms

      // Initialize order book and start polling
      async function initOrderBook() {
        try {
          // Get initial snapshot from Binance using CORS proxy
          const response = await fetch('https://api.codetabs.com/v1/proxy?quest=' + 
            encodeURIComponent('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=1000'));
          const snapshot = await response.json();
          
          // Initialize order book with snapshot
          orderBook.lastUpdateId = snapshot.lastUpdateId;
          orderBook.asks.clear();
          orderBook.bids.clear();
          
          snapshot.asks.forEach(([price, size]) => {
            orderBook.asks.set(price, parseFloat(size));
          });
          
          snapshot.bids.forEach(([price, size]) => {
            orderBook.bids.set(price, parseFloat(size));
          });

          // Initialize time bins
          initTimeBins();
          
          // Start polling for updates
          startPolling();

          // Initial draw
          drawHeatmap();
        } catch (error) {
          console.error('Error initializing order book:', error);
          setTimeout(initOrderBook, 5000); // Retry after 5 seconds
        }
      }

      // Poll for order book updates
      async function pollOrderBook() {
        try {
          const response = await fetch('https://api.codetabs.com/v1/proxy?quest=' + 
            encodeURIComponent('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=100'));
          const data = await response.json();
          
          if (data.lastUpdateId > orderBook.lastUpdateId) {
            handleOrderBookUpdate(data);
          }
        } catch (error) {
          console.error('Error polling order book:', error);
        }
      }

      // Start polling loop
      function startPolling() {
        setInterval(pollOrderBook, POLL_INTERVAL);
      }

      // Initialize time-based bins
      function initTimeBins() {
        const now = Date.now();
        const currentBin = Math.floor(now / BIN_INTERVAL) * BIN_INTERVAL;
        
        timeBasedBins.clear();
        for (let i = 0; i < BINS_TO_KEEP; i++) {
          const binTime = currentBin - (i * BIN_INTERVAL);
          timeBasedBins.set(binTime, {
            asks: new Map(),
            bids: new Map()
          });
        }
      }

      // Handle order book updates
      function handleOrderBookUpdate(update) {
        // Process asks
        update.asks.forEach(([price, size]) => {
          if (parseFloat(size) === 0) {
            orderBook.asks.delete(price);
          } else {
            orderBook.asks.set(price, parseFloat(size));
          }
        });
        
        // Process bids
        update.bids.forEach(([price, size]) => {
          if (parseFloat(size) === 0) {
            orderBook.bids.delete(price);
          } else {
            orderBook.bids.set(price, parseFloat(size));
          }
        });
        
        // Update lastUpdateId
        orderBook.lastUpdateId = update.lastUpdateId;
        
        // Update time-based bins
        const now = Date.now();
        const currentBin = Math.floor(now / BIN_INTERVAL) * BIN_INTERVAL;
        
        // Create new bin if needed
        if (!timeBasedBins.has(currentBin)) {
          timeBasedBins.set(currentBin, {
            asks: new Map(),
            bids: new Map()
          });
          
          // Remove oldest bin
          const oldestBinTime = currentBin - (BINS_TO_KEEP * BIN_INTERVAL);
          timeBasedBins.delete(oldestBinTime);
        }
        
        // Aggregate current order book into current time bin
        const currentBinData = timeBasedBins.get(currentBin);
        
        orderBook.asks.forEach((size, price) => {
          const currentSize = currentBinData.asks.get(price) || 0;
          currentBinData.asks.set(price, currentSize + size);
        });
        
        orderBook.bids.forEach((size, price) => {
          const currentSize = currentBinData.bids.get(price) || 0;
          currentBinData.bids.set(price, currentSize + size);
        });
        
        // Draw updated heatmap
        drawHeatmap();
      }

      function drawHeatmap() {
        try {
          // Get canvas context
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match container
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          
          // Clear previous drawing
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Convert order book to array format
          const allOrders = [
            ...Array.from(orderBook.asks.entries()).map(([price, size]) => ({ price: parseFloat(price), size, type: 'ask' })),
            ...Array.from(orderBook.bids.entries()).map(([price, size]) => ({ price: parseFloat(price), size, type: 'bid' }))
          ];

          if (allOrders.length === 0) return;

          // Wait for TradingView chart to be ready and have price data
          if (!chartReady || !priceRange.max) {
            console.log("Waiting for chart data...");
            return;
          }

          // Use TradingView's price range for better coordination
          const xScale = d3.scaleLinear()
            .domain([priceRange.min * 0.9985, priceRange.max * 1.0015]) // Add small padding
            .range([0, canvas.width]);

          // Create color scale (purple to green/yellow)
          const maxSize = Math.max(...allOrders.map(order => order.size));
          const colorScaleLow = d3.scaleLinear()
            .domain([0, maxSize * 0.5])
            .range(["#540D6E", "#14FFEC"]);
          const colorScaleHigh = d3.scaleLinear()
            .domain([maxSize * 0.5, maxSize])
            .range(["#14FFEC", "#F6FF00"]);
          
          const getColor = (size) => {
            return size <= maxSize * 0.5 ? colorScaleLow(size) : colorScaleHigh(size);
          };
          
          const logScale = d3.scaleLog()
            .domain([1, maxSize])
            .range([0.2, 0.8]);

          // Aggregate orders into price bins
          const binSize = (priceRange.max - priceRange.min) / 100; // 100 price levels
          const priceBins = new Map();
          
          allOrders.forEach(order => {
            const binIndex = Math.floor((order.price - priceRange.min) / binSize);
            const binPrice = priceRange.min + (binIndex * binSize);
            
            if (!priceBins.has(binPrice)) {
              priceBins.set(binPrice, { bids: 0, asks: 0 });
            }
            
            const bin = priceBins.get(binPrice);
            if (order.type === 'bid') {
              bin.bids += order.size;
            } else {
              bin.asks += order.size;
            }
          });

          // Draw aggregated heatmap with gradient
          priceBins.forEach((volumes, price) => {
            const x = xScale(price);
            const rectWidth = Math.max(2, canvas.width / priceBins.size);
            
            // Draw asks (top half)
            const askGradient = ctx.createLinearGradient(0, 0, 0, canvas.height/2);
            const askAlpha = volumes.asks > 0 ? logScale(volumes.asks) : 0;
            askGradient.addColorStop(0, getColor(volumes.asks));
            askGradient.addColorStop(0.7, `rgba(84, 13, 110, ${askAlpha * 0.7})`);
            askGradient.addColorStop(1, 'rgba(84, 13, 110, 0)');
            
            ctx.globalAlpha = askAlpha;
            ctx.fillStyle = askGradient;
            ctx.fillRect(x, 0, rectWidth, canvas.height/2);
            
            // Draw bids (bottom half)
            const bidGradient = ctx.createLinearGradient(0, canvas.height/2, 0, canvas.height);
            const bidAlpha = volumes.bids > 0 ? logScale(volumes.bids) : 0;
            bidGradient.addColorStop(0, 'rgba(84, 13, 110, 0)');
            bidGradient.addColorStop(0.3, `rgba(84, 13, 110, ${bidAlpha * 0.7})`);
            bidGradient.addColorStop(1, getColor(volumes.bids));
            
            ctx.globalAlpha = bidAlpha;
            ctx.fillStyle = bidGradient;
            ctx.fillRect(x, canvas.height/2, rectWidth, canvas.height/2);
          });
        } catch (err) {
          console.error("Error rendering heatmap:", err);
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'red';
          ctx.font = '14px Arial';
          ctx.fillText('Error rendering heatmap. Please check console for details.', 10, 20);
        }
      }

      // Market Data Functions
      async function updateMarketData() {
        try {
          // Fetch data from Binance API with better CORS proxy
          const [volumeRes, oiRes] = await Promise.all([
            fetch('https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT')),
            fetch('https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent('https://fapi.binance.com/futures/data/openInterestHist?symbol=BTCUSDT&period=5m&limit=1'))
          ]);

          const volumeData = await volumeRes.json();
          const oiData = await oiRes.json();

          // Validate and format volume data
          if (!volumeData || !volumeData.volume || !volumeData.lastPrice) {
            throw new Error('Invalid volume data structure');
          }
          const volume = parseFloat(volumeData.volume * volumeData.lastPrice);
          document.getElementById('volVal').textContent = '$' + (volume / 1e9).toFixed(2) + 'B';

          // Validate and format open interest data
          if (!oiData || !Array.isArray(oiData) || oiData.length === 0 || !oiData[0].sumOpenInterest) {
            throw new Error('Invalid open interest data structure');
          }
          const oi = parseFloat(oiData[0].sumOpenInterest);
          document.getElementById('oiVal').textContent = '$' + (oi / 1e9).toFixed(2) + 'B';

          // Simulate liquidation and L/S ratio (as these require paid API access)
          const mockLiq = (Math.random() * 100 + 200).toFixed(2);
          const mockLSRatio = (Math.random() * 0.2 + 0.9).toFixed(2);
          
          document.getElementById('liqVal').textContent = '$' + mockLiq + 'M';
          document.getElementById('lsVal').textContent = mockLSRatio;
        } catch (err) {
          console.error('Error updating market data:', err);
          ['volVal', 'oiVal', 'liqVal', 'lsVal'].forEach(id => {
            document.getElementById(id).textContent = 'Error loading data';
          });
        }
      }

      // Initialize order book and market data
      initOrderBook();
      updateMarketData();
      setInterval(updateMarketData, 10000);
    </script>
    <!-- Heatmap Section END -->
  </body>
</html>
