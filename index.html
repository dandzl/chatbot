<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>BTC Chart</title>
  </head>
  <body>
    <!-- Chart Container BEGIN -->
    <div style="position: relative; width: 800px; height: 600px;">
      <!-- TradingView Widget BEGIN -->
      <div id="tradingview_btc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
      <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
      <script type="text/javascript">
        let tvWidget;
        let chartReady = false;
        let lastPrice = 0;
        let priceRange = { min: 0, max: 0 };

        tvWidget = new TradingView.widget({
          autosize: true,
          symbol: "BINANCE:BTCUSDT",
          interval: "D",
          range: "12M",
          theme: "light",
          style: "1",
          timezone: "Etc/UTC",
          container_id: "tradingview_btc",
          onChartReady: function() {
            console.log("Chart is ready");
            chartReady = true;
            // Subscribe to real-time updates
            tvWidget.activeChart().onDataLoaded().subscribe(null, () => {
              const chart = tvWidget.activeChart();
              const prices = chart.getAllSeries()[0].data();
              if (prices && prices.length > 0) {
                lastPrice = prices[prices.length - 1].close;
                const visibleRange = chart.getVisibleRange();
                const priceData = prices.filter(p => 
                  p.time >= visibleRange.from && p.time <= visibleRange.to
                );
                priceRange.min = Math.min(...priceData.map(p => p.low));
                priceRange.max = Math.max(...priceData.map(p => p.high));
              }
            });
          }
        });
      </script>
      <!-- TradingView Widget END -->
      
      <!-- Heatmap Overlay BEGIN -->
      <canvas id="heatmapCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
    </div>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      // WebSocket and OrderBook state
      let ws = null;
      let orderBook = {
        asks: new Map(),
        bids: new Map(),
        sequence: 0
      };

      // Initialize WebSocket connection
      async function initWebSocket() {
        try {
          // Get initial snapshot
          const response = await fetch("https://api.allorigins.win/raw?url=" + 
            encodeURIComponent("https://api.kucoin.com/api/v1/market/orderbook/level2_100?symbol=BTC-USDT"));
          const snapshot = await response.json();
          
          // Initialize order book with snapshot
          orderBook.sequence = parseInt(snapshot.data.sequence);
          orderBook.asks.clear();
          orderBook.bids.clear();
          
          snapshot.data.asks.forEach(([price, size]) => {
            orderBook.asks.set(price, parseFloat(size));
          });
          
          snapshot.data.bids.forEach(([price, size]) => {
            orderBook.bids.set(price, parseFloat(size));
          });

          // Get WebSocket token and endpoint
          const tokenResponse = await fetch("https://api.allorigins.win/raw?url=" + 
            encodeURIComponent("https://api.kucoin.com/api/v1/bullet-public"));
          const tokenData = await tokenResponse.json();
          const token = tokenData.data.token;
          const wsEndpoint = tokenData.data.instanceServers[0].endpoint;
          
          // Close existing WebSocket if any
          if (ws) {
            ws.close();
          }
          
          // Connect to WebSocket
          ws = new WebSocket(`${wsEndpoint}?token=${token}`);
          
          ws.onopen = () => {
            console.log('WebSocket connected');
            // Subscribe to level2 market data
            ws.send(JSON.stringify({
              "id": Date.now(),
              "type": "subscribe",
              "topic": "/market/level2:BTC-USDT",
              "response": true
            }));
          };
          
          ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'message' && data.subject === 'trade.l2update') {
              handleOrderBookUpdate(data.data);
            }
          };
          
          ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            setTimeout(initWebSocket, 5000); // Reconnect after 5 seconds
          };
          
          ws.onclose = () => {
            console.log('WebSocket disconnected');
            setTimeout(initWebSocket, 5000); // Reconnect after 5 seconds
          };

          // Initial draw
          drawHeatmap();
        } catch (error) {
          console.error('Error initializing WebSocket:', error);
          setTimeout(initWebSocket, 5000); // Retry after 5 seconds
        }
      }

      // Handle order book updates
      function handleOrderBookUpdate(update) {
        if (update.sequenceStart <= orderBook.sequence + 1) {
          // Process asks
          update.changes.asks.forEach(([price, size]) => {
            if (parseFloat(size) === 0) {
              orderBook.asks.delete(price);
            } else {
              orderBook.asks.set(price, parseFloat(size));
            }
          });
          
          // Process bids
          update.changes.bids.forEach(([price, size]) => {
            if (parseFloat(size) === 0) {
              orderBook.bids.delete(price);
            } else {
              orderBook.bids.set(price, parseFloat(size));
            }
          });
          
          orderBook.sequence = update.sequenceEnd;
          drawHeatmap();
        } else {
          // Sequence broken, reinitialize
          initWebSocket();
        }
      }

      function drawHeatmap() {
        try {
          // Get canvas context
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match container
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          
          // Clear previous drawing
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Convert order book to array format
          const allOrders = [
            ...Array.from(orderBook.asks.entries()).map(([price, size]) => ({ price: parseFloat(price), size, type: 'ask' })),
            ...Array.from(orderBook.bids.entries()).map(([price, size]) => ({ price: parseFloat(price), size, type: 'bid' }))
          ];

          if (allOrders.length === 0) return;

          // Wait for TradingView chart to be ready and have price data
          if (!chartReady || !priceRange.max) {
            console.log("Waiting for chart data...");
            return;
          }

          // Use TradingView's price range for better coordination
          const xScale = d3.scaleLinear()
            .domain([priceRange.min * 0.9985, priceRange.max * 1.0015]) // Add small padding
            .range([0, canvas.width]);

          // Create color scale (purple to green/yellow)
          const colorScale = d3.scaleSequential()
            .domain([0, Math.max(...allOrders.map(order => order.size))])
            .interpolator(d3.interpolateHsl("#540D6E", "#F6FF00"));

          // Aggregate orders into price bins
          const binSize = (priceRange.max - priceRange.min) / 100; // 100 price levels
          const priceBins = new Map();
          
          allOrders.forEach(order => {
            const binIndex = Math.floor((order.price - priceRange.min) / binSize);
            const binPrice = priceRange.min + (binIndex * binSize);
            
            if (!priceBins.has(binPrice)) {
              priceBins.set(binPrice, { bids: 0, asks: 0 });
            }
            
            const bin = priceBins.get(binPrice);
            if (order.type === 'bid') {
              bin.bids += order.size;
            } else {
              bin.asks += order.size;
            }
          });

          // Draw aggregated heatmap with gradient
          priceBins.forEach((volumes, price) => {
            const x = xScale(price);
            const rectWidth = Math.max(2, canvas.width / priceBins.size);
            
            // Draw asks (top half)
            const askGradient = ctx.createLinearGradient(0, 0, 0, canvas.height/2);
            askGradient.addColorStop(0, colorScale(volumes.asks));
            askGradient.addColorStop(1, 'rgba(84, 13, 110, 0)'); // Fade to transparent
            
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = askGradient;
            ctx.fillRect(x, 0, rectWidth, canvas.height/2);
            
            // Draw bids (bottom half)
            const bidGradient = ctx.createLinearGradient(0, canvas.height/2, 0, canvas.height);
            bidGradient.addColorStop(0, 'rgba(84, 13, 110, 0)'); // Fade to transparent
            bidGradient.addColorStop(1, colorScale(volumes.bids));
            
            ctx.fillStyle = bidGradient;
            ctx.fillRect(x, canvas.height/2, rectWidth, canvas.height/2);
          });
        } catch (err) {
          console.error("Error rendering heatmap:", err);
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'red';
          ctx.font = '14px Arial';
          ctx.fillText('Error rendering heatmap. Please check console for details.', 10, 20);
        }
      }

      // Initialize WebSocket connection
      initWebSocket();
    </script>
    <!-- Heatmap Section END -->
  </body>
</html>
